1) входной поток(source) на нашем языке
(
a=1
b=1
b=a+1
while(a<10){
a=a+2;
}
)
для этого языка конечно есть грамматика,
которая у нас описана отдельно

2) source разбить на токены
a=1
 тут 3 токена:
 new Token(Lexem.VAR, "a")
 new Token(Lexem.ASSIGN_OP, "=")
 new Token(Lexem.DIGIT, "1")

source
  a=1

1) Ждём "удачи"
2) Записываем первый символ из source в acc
3) Начинаем искать всеми регулярными выражениями лексем в этом acc



============================

1) Префиксный !true

2) Инфиксный a+b

3) Постфиксный ab+
====================
Плюсы постфиксной формы записи:

- удобство выполнения на стеке
- "плоская структура" - отсутствие скобок
====================

1+3+4+5 T

ПОЛИЗ: 1 3 + 4 + 5 +

ВРЕМЕННЫЙ СТЕК ОПЕРАЦИЙ: T

- операнды сразу идут в полиз
- операции идут в стек
- конец выражения вытесняет всё из стека операций
====================

СТЕК машина принимает на вход ПОЛИЗ и вычисляет его:

1 3 + 4 + 5 +
3 + 4 + 5 +
+ 4 + 5 +
4 + 5 +
+ 5 +
5 +
+

СТЕК ОПЕРАНДОВ (вход сверху) - LIFO (last in first out) :
верх_стека 1 низ_стека
верх_стека 3 1 низ_стека
верх_стека низ_стека
верх_стека 4 низ_стека
верх_стека 4 4 низ_стека
верх_стека низ_стека
верх_стека 8 низ_стека
верх_стека 5 8 низ_стека
верх_стека низ_стека
верх_стека 13 низ_стека

====================
(1+3)*4+15 T

ПОЛИЗ: 1 3 + 4 * 15 +

ВРЕМЕННЫЙ СТЕК ОПЕРАЦИЙ: (+)
ВРЕМЕННЫЙ СТЕК ОПЕРАЦИЙ: *
ВРЕМЕННЫЙ СТЕК ОПЕРАЦИЙ: +
ВРЕМЕННЫЙ СТЕК ОПЕРАЦИЙ:
- закрывающая скобка вытесняет все операции до открывающей
- арифм операция МЕНЬШЕГО приоритета вытесняет более приоритетную операцию

3 1
4
4 4
16
15 16
31
====================
a = b + 1
a b 1 + =

1 b a
(1+b) a

таблица переменных меняется каждый раз при выполнении операции присваивания

a = (1+b)
====================

p! - безусловный переход (p - метка перехода - это номер элемента
в полизе, который будет помещён СЛЕДУЮЩИМ в стекмашину при выполнении
ПОЛИЗ, ! - собственно операция, которая инициирует такое помещение
в стекмашину)

b p !F - b - это логическое значение (true/false), p - метка перехода

!F - оператор перехода по лжи, то есть если b = false, то следующий номер элемента,
который попадёт в стек машину будет p

====================

while(a<3){a=a+1}c=3

a 3 < p1 !F a a 1 + = p2 !  c  3  =  T
0 1 2 3  4  5 6 7 8 9 10 11 12 13 14 15

a 3 < 12 !F a a 1 + = 0  !  c  3  =  T
0 1 2 3  4  5 6 7 8 9 10 11 12 13 14 15

имя перменной | значение переменной
        a               3
        c               3

номер элемента полиза для считывания = 15
верх_стека низ_стека

lt(3, 3) = false
!F(false, 12)
add(a, 1)
assign(c, 3)
!(0)

for (a = 0; a < 3; a=a+1) {}
->
a=0;while(a<3){a=a+1 ... далее выражения из тела for
